# 特权级

tss(task state segment)任务状态段:硬件上原生支持的多任务的 一种实现方式。

每个任务在每个特权级下只能有一个栈。

特权级转移分为两类，一类是由中断门、调用门等手段实现低特权转向高级特权，另一类又调用返回指令从高到低，这是唯一一种能让处理器降级的的手段。

tss不需要第三特权级的栈，因为不会有更低的特权级栈向它转移。

tss由tr寄存器载入，切换任务就加载不同的tss.

三个特权级标签:DPL\RPL\CPL

**RPL(请求特权等级):**位于选择子第0～1位。代表请求他人其他能力的等级。代码段寄存器cs和指令指针寄存器eip中指向的指令便是当前在处理器中正在运行的代码，所以又称为处理器的当前特权级。(CS.RPL)[只是代码段寄存器cs中的rpl是cpl，其他段寄存器中选择子的rpl与cpl无关]

**CPL(当前特权级):**运行的指令属于某个代码段，代码描述符中的dpl，便是当前cpu所处的特权级。

指令最终是用处理器执行的，执行到不同特权的代码，处理器的特权就换到不同的等级。所以cpl是指cpu在当前计算机的特权级别。

当处理器特权级检查通过后，新代码段的dpl就变成了处理器的cpl，也就是目标代码段的描述符的dpl将保存在代码寄存器cs中的rpl位。

**DPL(受访者特权标签)**:为该内存标明特权等级。



------

访问者不允许访问比自己特权等级更高的资源。

1. 对于数据段，只有访问者权限**大于等于**该dpl表示的最低权限才能够继续访问。
2. 对于代码段，只有只有访问者权限**等于**该dpl表示的最低权限才能够继续访问。因为没必要把高特权级降到低特权级。

## 如何转移到特权级比自己更高的代码段？

**一致性代码段(依从(conforming)代码段)：**用来实现从低特权级向高特权级的转移。一致性代码段是指如果自己是转移后的代码段，那么自己的dpl一定要 **大于等于** 转移前的代码段的cpl。

1. 在段描述中，该段为非系统段(S字段为0)。
2. type字段中的c位为1时是一致性代码段。

**依从代码段最大的特点是转移后的cpl不以自己的dpl一致，而是以转移前的低特权级一致**。

在特权级检查中，rpl并不参与。

数据段总是非一致的。

**门**：就是记录一段程序起始地址的描述符。

处理器只有通过 门结构 才能从低特权到搞特权的转移。cpu便是如此设计的。

在保护模式下，中断描述符表（IDT）中的每个表项由8个字节组成，其中的每个表项叫做一个门描述符（Gate Descriptor）， “门”的含义是指当中断发生时必须先访问这些“门”，能够“开门”（即将要进行的处理需通过特权检查，符合设定的权限等约束）后，然后才能进入相应的处理程序。而门描述符则描述了“门”的属性（如特权级、段内偏移量等）。

![image-20200908100659724](/Users/lonekriss/Library/Application Support/typora-user-images/image-20200908100659724.jpg)

门与段描述符最大的区别在于，除了任务门，每个门都对应一段例程，即对应一段函数，而不是像段描述符一样对应一段内存。

任务门可以放在GDT/LDT/IDT

调用门可以放在GDT/IDT

中段门和陷阱门只能放在IDT

任务门和调用门可以用call和jmp指令调用。中断门和陷阱门只能通过中断信号来出发调用。

任务门是通过tss选择子来描述一个任务。其他的用代码段选择子。由于在门描述符中已经记载了偏移量，所以call或者jmp中的偏移量会被忽略。

## 与门有关的功用

调用门:使用jmp可以平级转移，call实现高特权代码转移。

中断门:int指令实现从低到高特权转移。

陷阱门:in3，一般是编译器调试时使用。

任务门：用来实现任务切换。



现代操作系统很少用到调用门 (兼容性问题)和任务门。

门的门槛是访问者特权级的下限，门描述的dpl要低于或等于当前特权级cpl,即数值上 cpl<=门的dpl。

门的门框是访问者特权级的上限。访问者的特权级再高也不能比门描述符中 目标

程序所在代码段的dpl高。否则就意味着从高到低特权转移。这是绝对禁止的。数值上cpl>=目标代码段dpl。

进门后，处理器将以目标代码段dpl为当前特权级cpl。



不同权限级使用不同的栈，那如何使用cpl为3的参数传入到dpl为0的栈里？答案是cpu为我们自动复制了压入特权级3中的参数。



在retf返回时如果需要改变特权级，将会检查数据段寄存器ds/es/fs/gs，如果数据段权限比cs高，[段寄存器不重新加载就不会检查特权级]则会向相应数据段填充0(gdt0是哑描述符)，从而引发处理器异常。





rpl完美解决了受访者不知道访问者的真实身份。rpl代表了真正请求者的特权级。

操作系统会把系统选择子的rpl改为用户程序的cpl。而且，在平坦模式下，因为虚拟地址的存在，只需要两个选择子，一个代码段，一个数据段就足够程序内部使用。arpl可以修改选择子中的rpl。

`arpl 通用寄存器/16位内存,16位通用寄存器`一般为用户提交的选择子，用户段寄存器cs的值



总结：

如果用门调用，数值上dpl_gate>=cpl>=dpl_code，rpl<=dpl_gate

始终cpl<=dpl&&rpl<=dpl，*操作系统会自动修改用户提交的选择子中的rpl为它当前代码段cpl，所以就伪造不了rpl*

